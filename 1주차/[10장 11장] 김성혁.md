### 객체란?

자바스크립트에서 원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등)을 객체라고 부릅니다. 원시 값을 제외한 나머지 값을 객체라고도 부르지만, 객체 타입의 값(object/reference type) 또한 객체라고 부르는 것으로 보입니다.



자바스크립트에서는 원시 타입의 값을 `mutable`과 객체 타입의 값을 `immutable`로 정의하고 있습니다.



- 객체는 프로퍼티와 메서드로 구성된 집합체
  - 프로퍼티: 객체의 상태를 나타내는 값
    - 프로퍼티 값이 함수일 경우 메서드라고 부름
  - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)



💡 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다.



자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있습니다. 배열도 프로퍼티 값이 될 수 있고, 함수도 프로퍼티 값이 될 수 있습니다.



```jsx
var car = {
	position: 0,
	move: function() {
		this.position++;
	}
};
```



💡 자바스크립트는 프로토타입 기반 객체지향 언어입니다.



[프로토타입이란?](https://www.notion.so/9f35110727da45a4b0ef05261e2e2acc)



### **객체 생성 방법**

- 객체 리터럴

  ```jsx
  var car = {
  	position: 0,
  	move: function() {
  		this.position++;
  	}
  };
  ```

- Object 생성자 함수

  ```jsx
  var car = new Object();
  car.position = 0;
  ```

- 생성자 함수

  기존 함수에 new 연산자를 붙여서 호출하면, 생성자 함수로 동작합니다.

  ```jsx
  function Car(position) {
  	this.position = position
  }
  
  var car1 = new Car(5);
  ```

- Object.create 메서드

  지정된 프로토타입(prototype) 객체와 프로퍼티를 가지고 새로운 객체를 만들어 주는 방법을 제공

  ```jsx
  Object.create(proto[, propertiesObject])
  ```

- 클래스(ES6)

  ```jsx
  class 클래스이름 {
  	...
  }
  ```



### 프로퍼티

객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성됩니다. 식별자 네이밍 규칙을 준수하는 프로퍼티 키는 따옴표를 생략할 수 있지만, 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 붙여야 합니다.

```jsx
var car = {
	lastPoition: 0, // 식별자 네이밍 규칙을 준수하는 프로퍼티 키
	last-position: 0 // 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키
};
```



- 프로퍼티 키를 동적으로도 생성 가능합니다.

  ```jsx
  var car = {};
  var key = position;
  
  car[key] = 5;
  ```

  

- 빈 문자열은 프로퍼티 키로서 의미를 갖지 못합니다.

- 프로퍼티 키에 문자열이나 심벌 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 됩니다.

- 예약어를 프로퍼티 키로 사용하는 것은 권장하지 않습니다.

- 프로퍼티 키의 중복을 권장하지 않습니다.

- `delete` 연산자를 통해 프로퍼티를 삭제할 수 있습니다.



### 프로퍼티 접근

프로퍼티 값은 마침표 프로퍼티 접근 연산자(.)와 대괄호 프로퍼티 접근 연산자([…])를 통해 접근 가능합니다.

```jsx
var car = {
	position: 5
};

console.log(car.position); // 5
console.log(car['position']); // 5
```

- 객체에 존재하지 않는 프로퍼티에 접근하면 `undefined` 를 반환합니다.



### ES6에 추가된 스펙

- 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있습니다.

  ```jsx
  let x = 1, y = 2;
  
  const obj = { x, y };
  
  cosole.log(obj); // { x: 1, y: 2 }
  ```

- 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있습니다.

  ```jsx
  // ES5
  var obj = {};
  
  obj["key"] = 1;
  
  console.log(obj); // { key: 1 }
  
  // ES6
  const obj = {
  	["key"]: 1
  };
  
  console.log(obj); // { key: 1 }
  ```

- 메서드를 정의할 때 fucntion 키워드를 생략한 축약 표현이 가능합니다. 대신 해당 표현은 프로퍼티에 할당한 함수와 다르게 동작합니다.

  ```jsx
  // ES5
  var obj = {
  	name: 'KIM',
  	sayHello: function() {
  		console.log("Hello, " + this.name);
  	}
  }
  
  // ES6
  const obj = {
  	name: 'KIM',
  	sayHello() {
  		console.log("Hello, " + this.name);
  	}
  }
  ```



# 11장

**원시 타입과 객체 타입의 차이**

- 원시 타입의 값은 변경 가능한 값(immutable)이고, 객체 타입의 값은 변경 가능한 값(mutable)입니다.
- 원시 값은 확보된 메모리에 실제 값이 저장되고, 객체를 확보된 메모리 공간에 저장하면 참조 값이 저장됩니다.
- 원시 값을 갖는 변수는 복사될 때 `pass by value` , 객체 값을 갖는 변수는 복사될 때 `pass by reference`



💡 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 `불변성` 이라고 합니다.



**불변성이 중요한 이유?**

- 불변성을 지키지 않을 경우 예기치 않게 변수 값이 변경될 수 있기에 값의 변경, 즉 상태 변경을 추적하기 어렵게 만듭니다.



💡 원시 타입은 브라우저 제조사의 구현에 따라 원시 타입의 크기는 다를 수 있습니다.



**문자열의 불변성**

자바스크립트의 문자열은 immutable입니다. 이는 새로운 문자열이 생성되면 새로운 메모리 공간을 할당한다는 것을 의미합니다. 자바스크립트에서 문자열은 **유사 배열 객체** 즉, 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖습니다. 또한, 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않습니다. 이는 예기치 않는 변경 상황을 예방하며 데이터의 신뢰성을 보장합니다.

```jsx
var str = 'KIM';

str[0] = 'Z'; // 에러는 발생하지 않지만 변경되지 않음.자
```



💡 자바에서는 객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없지만, 자바스크립트는 클래스 없이 객체를 생성할 수 있으며 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있습니다. 이는 사용이 편리하지만 성능면에서 생성과 프로퍼티 접근에 많은 비용이 듭니다.



- “여러 개의 식별자가 하나의 객체를 공유하는 것이 가능하다”는 어떤 말인가?

  ```jsx
  var person = {
  	name: 'KIM';
  }
  
  // 참조 값을 복사(얕은 복사)
  var copy = personㅁㅈ차
  ```

  참조에 의해 복사되기 때문에 같은 메모리 주소를 공유합니다. 그렇기에 다른 한쪽에서 객체를 변경하면 서로 영향을 주고 받습니다. 이를 그래서 “공유에 의한 전달”이라고 표현하는 경우도 있습니다.



### 깊은 복사와 얕은 복사

얕은 복사는 객체의 참조값을 복사하는 것, 깊은 복사는 객체의 실제 값을 복사하는 것

```jsx
const obj = {
	x: { y: 1 }
};

// 얕은 복사
const copy = { ...obj };
console.log(copy === obj); // false
console.log(copy.x === obj.x); // true

// 깊은 복사
const _ = require('lodash');
const copy2 = _.cloneDeep(o);
console.log(copy2 === o); // false
console.log(copy2.x === o.x); // false
```